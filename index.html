<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gemini 3 Flash: 3D Object Generator</title>

  <!-- Links to css -->
  <link rel="stylesheet" type="text/css" href="./3D-Gen.css">

  <!-- Three.js -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>

<div id="ui-container">
  <header>
    <h1>Gemini - 3D Generator</h1>
    <div id="status">Ready</div>
  </header>

  <div id="api-key-section">
    <input
      type="password"
      id="api-key"
      placeholder="Gemini API Key"
    />
    <small>
      Get your key at 
      <a href="https://aistudio.google.com/apikey" target="_blank" style="color: var(--accent-blue); text-decoration: none;">
        Google AI Studio
      </a>
    </small>
  </div>

  <hr style="border: 0; border-top: 1px solid var(--border-color); margin: 5px 0;">

  <div style="display: flex; flex-direction: column; gap: 10px;">
    <label style="font-size: 12px; color: var(--text-dim);">PROMPT</label>
    <input
      type="text"
      id="prompt"
      placeholder="e.g. A comfy sofa"
    />
    <button id="generate-btn">Generate Object</button>
  </div>

  <button id="download-btn" class="hidden">Download .GLB</button>
</div>

<!-- JavaScript -->
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";

/* =========================
   THREE.JS SCENE SETUP
========================= */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
scene.fog = new THREE.Fog(0x111111, 10, 60);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 6, 12);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0x404040, 0.7);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(10, 20, 10);
sun.castShadow = true;
scene.add(sun);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.GridHelper(50, 50, 0x444444, 0x222222));

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* =========================
   API KEY MANAGEMENT
========================= */

const apiKeyInput = document.getElementById("api-key"); // No storage - user enters key each session for security

/* =========================
   GEMINI 3 INTEGRATION
========================= */

const generateBtn = document.getElementById("generate-btn");
const statusDiv = document.getElementById("status");
const downloadBtn = document.getElementById("download-btn");

let generatedObjects = [];

generateBtn.addEventListener("click", async () => {
  const prompt = document.getElementById("prompt").value.trim();
  const apiKey = apiKeyInput.value.trim();

  if (!apiKey) {
    statusDiv.innerText = "âš ï¸ Please enter your Gemini API key";
    apiKeyInput.focus();
    return;
  }

  if (!prompt) {
    statusDiv.innerText = "âš ï¸ Please enter a scene description";
    return;
  }

  generateBtn.disabled = true;
  statusDiv.innerText = "ðŸ¤– Gemini 3 Flash is generating your 3D object...";

  const systemPrompt = `You are an expert Three.js developer creating 3D scenes or objects.

Write JavaScript code that creates a 3D object based on the user's request.

CRITICAL RULES:
1. Use ONLY Three.js primitives (BoxGeometry, SphereGeometry, CylinderGeometry, PlaneGeometry, etc.)
2. Do NOT create lights, camera, renderer, or controls - these already exist
3. Set castShadow = true and receiveShadow = true on all meshes
4. Use realistic scales and positioning
5. Create varied, interesting compositions with multiple objects
6. Use appropriate materials (MeshStandardMaterial, MeshPhongMaterial)
7. Add colors and textures where appropriate
8. Output ONLY raw JavaScript code - no markdown, no explanations
9. Create a THREE.Group named 'meshGroup', add all meshes to it, and ensure 'meshGroup' is the final output.
10. Example structure:

const meshGroup = new THREE.Group();

const geometry1 = new THREE.BoxGeometry(2, 2, 2);
const material1 = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const mesh1 = new THREE.Mesh(geometry1, material1);
meshGroup.add(mesh1);

// Add more objects...

USER REQUEST:
${prompt}

Remember: Output ONLY the JavaScript code, nothing else.`;

  try {
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=${apiKey}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [
            {
              parts: [{ text: systemPrompt }]
            }
          ],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 8192,
          }
        })
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error?.message || `API Error: ${response.status}`);
    }

    const data = await response.json();

    if (!data.candidates?.length) {
      throw new Error("No response from Gemini");
    }

    let code = data.candidates[0].content.parts[0].text;
    
    // Remove markdown code blocks if present
    code = code.replace(/```javascript\n?/g, "");
    code = code.replace(/```js\n?/g, "");
    code = code.replace(/```\n?/g, "");
    code = code.trim();

    console.log("Generated code:", code);

    // Cleanup previous meshes
    generatedObjects.forEach(m => {
      scene.remove(m);
      if (m.geometry) m.geometry.dispose();
      if (m.material) {
        if (Array.isArray(m.material)) {
          m.material.forEach(mat => mat.dispose());
        } else {
          m.material.dispose();
        }
      }
    });
    generatedObjects = [];

    // Execute the generated code
    let meshGroup;
    try {
        // We pass THREE and scene, and expect the code to return 'meshGroup'
        const fn = new Function("THREE", "scene", code + "\nreturn meshGroup;");
        meshGroup = fn(THREE, scene);
    } catch (execError) {
        console.error("Code execution error:", execError);
        throw new Error(`Failed to execute generated code: ${execError.message}`);
    }

    if (!meshGroup || !meshGroup.isGroup) {
        throw new Error("No valid mesh group was generated");
    }

    // Add the group to the scene
    scene.add(meshGroup);
    generatedObjects.push(meshGroup); // Store the group as a single reference

    statusDiv.innerText = `âœ… Scene built successfully (${generatedObjects.length} objects)`;
    downloadBtn.style.display = "block";

    // Focus camera on the scene
    if (generatedObjects.length > 0) {
      const box = new THREE.Box3();
      generatedObjects.forEach(obj => box.expandByObject(obj));
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = maxDim * 2;
      
      camera.position.set(center.x + distance, center.y + distance * 0.7, center.z + distance);
      camera.lookAt(center);
      controls.target.copy(center);
    }

  } catch (err) {
    console.error("Error:", err);
    statusDiv.innerText = `âŒ Error: ${err.message}`;
  }

  generateBtn.disabled = false;
});

/* =========================
   EXPORT TO GLB
========================= */

downloadBtn.addEventListener("click", () => {
  if (!generatedObjects.length) {
    statusDiv.innerText = "âš ï¸ No objects to export";
    return;
  }

  statusDiv.innerText = "ðŸ“¦ Preparing GLB export...";

  const exporter = new GLTFExporter();
  const exportScene = new THREE.Scene();

  generatedObjects.forEach(obj => {
    const clone = obj.clone();
    exportScene.add(clone);
  });

  exporter.parse(
    exportScene,
    result => {
      const blob = new Blob([result], { type: "application/octet-stream" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "gemini-vibe-object.glb";
      a.click();
      statusDiv.innerText = "âœ… GLB downloaded successfully!";
      setTimeout(() => {
        statusDiv.innerText = `Scene ready (${generatedObjects.length} objects)`;
      }, 3000);
    },
    err => {
      console.error("Export error:", err);
      statusDiv.innerText = `âŒ Export failed: ${err.message}`;
    },
    { binary: true }
  );
});

// Handle Enter key for generation
document.getElementById("prompt").addEventListener("keypress", (e) => {
  if (e.key === "Enter" && !generateBtn.disabled) {
    generateBtn.click();
  }
});
</script>

</body>
</html>