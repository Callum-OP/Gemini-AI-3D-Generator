<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gemini 3 Flash: 3D Object Generator</title>

  <!-- Links to css -->
  <link rel="stylesheet" type="text/css" href="./3D-Gen.css">

  <!-- Three.js -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>

<body>

<button id="download-btn">Download .GLB</button>

<div id="ui-container">
  <div id="api-key-section">
    <label for="api-key">Gemini API Key:</label>
    <input
      type="password"
      id="api-key"
      placeholder="Enter your Gemini API key"
    />
    <small>
      Get your free API key at 
      <a href="https://aistudio.google.com/apikey" target="_blank" style="color: #4285f4;">
        Google AI Studio
      </a>
      (not stored - enter each session)
    </small>
  </div>

  <div class="row">
    <input
      type="text"
      id="prompt"
      placeholder="Describe your 3D object (e.g. 'A wooden chair')"
    />
    <button id="generate-btn">Build It</button>
  </div>
  <div id="status">Ready - Enter your API key to begin</div>
</div>

<!-- JavaScript -->
<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFExporter } from "three/addons/exporters/GLTFExporter.js";

/* =========================
   THREE.JS SCENE SETUP
========================= */

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
scene.fog = new THREE.Fog(0x111111, 10, 60);

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 6, 12);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0x404040, 0.7);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(10, 20, 10);
sun.castShadow = true;
scene.add(sun);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.GridHelper(50, 50, 0x444444, 0x222222));

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* =========================
   API KEY MANAGEMENT
========================= */

const apiKeyInput = document.getElementById("api-key"); // No storage - user enters key each session for security

/* =========================
   GEMINI 3 INTEGRATION
========================= */

const generateBtn = document.getElementById("generate-btn");
const statusDiv = document.getElementById("status");
const downloadBtn = document.getElementById("download-btn");

let generatedObjects = [];

generateBtn.addEventListener("click", async () => {
  const prompt = document.getElementById("prompt").value.trim();
  const apiKey = apiKeyInput.value.trim();

  if (!apiKey) {
    statusDiv.innerText = "âš ï¸ Please enter your Gemini API key";
    apiKeyInput.focus();
    return;
  }

  if (!prompt) {
    statusDiv.innerText = "âš ï¸ Please enter a scene description";
    return;
  }

  generateBtn.disabled = true;
  statusDiv.innerText = "ðŸ¤– Gemini 3 Flash is generating your 3D object...";

  const systemPrompt = `You are an expert Three.js developer creating 3D scenes or objects.

Write JavaScript code that creates a 3D object based on the user's request.

CRITICAL RULES:
1. Use ONLY Three.js primitives (BoxGeometry, SphereGeometry, CylinderGeometry, PlaneGeometry, etc.)
2. Do NOT create lights, camera, renderer, or controls - these already exist
3. Set castShadow = true and receiveShadow = true on all meshes
4. Use realistic scales and positioning
5. Create varied, interesting compositions with multiple objects
6. Use appropriate materials (MeshStandardMaterial, MeshPhongMaterial)
7. Add colors and textures where appropriate
8. Output ONLY raw JavaScript code - no markdown, no explanations
9. Create an array named 'newMeshes' containing all created meshes
10. Example structure:

const newMeshes = [];

const geometry1 = new THREE.BoxGeometry(2, 2, 2);
const material1 = new THREE.MeshStandardMaterial({ color: 0xff0000 });
const mesh1 = new THREE.Mesh(geometry1, material1);
mesh1.position.set(0, 1, 0);
mesh1.castShadow = true;
mesh1.receiveShadow = true;
newMeshes.push(mesh1);

// Add more objects...

USER REQUEST:
${prompt}

Remember: Output ONLY the JavaScript code, nothing else.`;

  try {
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=${apiKey}`,
      {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          contents: [
            {
              parts: [{ text: systemPrompt }]
            }
          ],
          generationConfig: {
            temperature: 0.7,
            maxOutputTokens: 8192,
          }
        })
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.error?.message || `API Error: ${response.status}`);
    }

    const data = await response.json();

    if (!data.candidates?.length) {
      throw new Error("No response from Gemini");
    }

    let code = data.candidates[0].content.parts[0].text;
    
    // Remove markdown code blocks if present
    code = code.replace(/```javascript\n?/g, "");
    code = code.replace(/```js\n?/g, "");
    code = code.replace(/```\n?/g, "");
    code = code.trim();

    console.log("Generated code:", code);

    // Cleanup previous meshes
    generatedObjects.forEach(m => {
      scene.remove(m);
      if (m.geometry) m.geometry.dispose();
      if (m.material) {
        if (Array.isArray(m.material)) {
          m.material.forEach(mat => mat.dispose());
        } else {
          m.material.dispose();
        }
      }
    });
    generatedObjects = [];

    // Execute the generated code
    let newMeshes = [];
    try {
      const fn = new Function("THREE", "scene", code + "\nreturn newMeshes;");
      newMeshes = fn(THREE, scene);
    } catch (execError) {
      console.error("Code execution error:", execError);
      throw new Error(`Failed to execute generated code: ${execError.message}`);
    }

    if (!Array.isArray(newMeshes) || newMeshes.length === 0) {
      throw new Error("No valid meshes were generated");
    }

    // Add meshes to scene
    newMeshes.forEach(m => {
      if (m && m.isMesh) {
        scene.add(m);
        generatedObjects.push(m);
      }
    });

    statusDiv.innerText = `âœ… Scene built successfully (${generatedObjects.length} objects)`;
    downloadBtn.style.display = "block";

    // Focus camera on the scene
    if (generatedObjects.length > 0) {
      const box = new THREE.Box3();
      generatedObjects.forEach(obj => box.expandByObject(obj));
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const distance = maxDim * 2;
      
      camera.position.set(center.x + distance, center.y + distance * 0.7, center.z + distance);
      camera.lookAt(center);
      controls.target.copy(center);
    }

  } catch (err) {
    console.error("Error:", err);
    statusDiv.innerText = `âŒ Error: ${err.message}`;
  }

  generateBtn.disabled = false;
});

/* =========================
   EXPORT TO GLB
========================= */

downloadBtn.addEventListener("click", () => {
  if (!generatedObjects.length) {
    statusDiv.innerText = "âš ï¸ No objects to export";
    return;
  }

  statusDiv.innerText = "ðŸ“¦ Preparing GLB export...";

  const exporter = new GLTFExporter();
  const exportScene = new THREE.Scene();

  generatedObjects.forEach(obj => {
    const clone = obj.clone();
    exportScene.add(clone);
  });

  exporter.parse(
    exportScene,
    result => {
      const blob = new Blob([result], { type: "application/octet-stream" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "gemini-vibe-object.glb";
      a.click();
      statusDiv.innerText = "âœ… GLB downloaded successfully!";
      setTimeout(() => {
        statusDiv.innerText = `Scene ready (${generatedObjects.length} objects)`;
      }, 3000);
    },
    err => {
      console.error("Export error:", err);
      statusDiv.innerText = `âŒ Export failed: ${err.message}`;
    },
    { binary: true }
  );
});

// Handle Enter key for generation
document.getElementById("prompt").addEventListener("keypress", (e) => {
  if (e.key === "Enter" && !generateBtn.disabled) {
    generateBtn.click();
  }
});
</script>

</body>
</html>